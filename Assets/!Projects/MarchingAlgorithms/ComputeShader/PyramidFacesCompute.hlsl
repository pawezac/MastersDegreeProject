#ifndef PYRAMIDFACES_INCLUDED
#define PYRAMIDFACES_INCLUDED

// Include helper functions from URP
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"
#include "NMGPyramidGraphicsHelpers.hlsl"

//this describes a vertex on the generated mesh, should match that in the compute shader
struct DrawVertex
{
	float3 positionWS; //position in world space
	float2 uv;
};

//a triangle
struct DrawTriangle
{
	float3 normalWS; // normal in world space , all points share this normal
	DrawVertex verticies[3]; // verticies need to be outputed as one object cause of how gpu works
};

//buffer to draw from. It is structured buffer now cause we need to read from it as from array
StructuredBuffer<DrawTriangle> _DrawTriangles;

// This structure is generated by the vertex function and passed to the geometry function
struct VertexOutput {
    float3 positionWS               : TEXCOORD0; // Position in world space
    float3 normalWS                 : TEXCOORD1; // Normal vector in world space
    float2 uv                       : TEXCOORD2; // UVs

    float4 positionCS               : SV_POSITION; // Position in clip space
};

// The _MainTex property. The sampler and scale/offset vector is also created
TEXTURE2D(_MainTex); SAMPLER(sampler_MainTex); float4 _MainTex_ST;
float4 _ColorTint;
// the SV_VERTEXID semantic is and index we can use to get a vertex to work on
// the max value of this is the first argument int the indirect args Buffer
// the system will create triangles out of each three consecutive vertices
VertexOutput Vertex(uint vertexID: SV_VERTEXID)
{
	//init the output struct
	VertexOutput output = (VertexOutput)0;

	//get the vertex from the Buffer
	// since the buffer is structured int triangles, we need to divide the vertexID by three
	// to get the triangle, and then modulo by 3 to get the vertex on the triangle
	DrawTriangle tri = _DrawTriangles[vertexID/3];
	DrawVertex input = tri.verticies[vertexID % 3];

	output.positionWS = input.positionWS;
	output.normalWS = tri.normalWS;
	output.uv = TRANSFORM_TEX(input.uv, _MainTex);
	
	//apply shadow caster logic to cs position
	output.positionCS = CalculatePositionCSWithShadowCasterLogic(input.positionWS, tri.normalWS);

	return output;
}

// the SV_TARGET semantic tells the compiler that this function outputs the pixel color
float4 Fragment(VertexOutput input): SV_TARGET
{
#ifdef SHADOW_CASTER_PASS
//IF IN SHADOW CASTER PASS JUST return
return 0;

#else

	//initialize some information for the lighting function
	InputData lightingInput = (InputData)0;
	SurfaceData surfaceInput = (SurfaceData)0;

	lightingInput.positionWS = input.positionWS;
	lightingInput.normalWS = input.normalWS; // no need to renormalize since triangles shadre normals
	lightingInput.viewDirectionWS = GetViewDirectionFromPosition(input.positionWS);
	lightingInput.shadowCoord = CalculateShadowCoord(input.positionWS, input.positionCS);

	float4 colorSample = SAMPLE_TEXTURE2D(_MainTex, sampler_MainTex, input.uv);

	surfaceInput.albedo = colorSample.rgb * _ColorTint.rgb;
	surfaceInput.alpha = colorSample.a * _ColorTint.a;

#if UNITY_VERSION >= 202120
	return UniversalFragmentBlinnPhong(lightingInput, surfaceInput);
#else
	return UniversalFragmentBlinnPhong(lightingInput, surfaceInput.albedo, float4(surfaceInput.specular, 1), surfaceInput.smoothness, 0, surfaceInput.alpha);
#endif
#endif
}
#endif
