using NaughtyAttributes;
using System;
using System.Drawing;
using UnityEngine;
using UnityEngine.UIElements;
using UnityEngine.Windows.Speech;

namespace MarchingTerrainGeneration
{
    public class Chunk : MonoBehaviour
    {
        [SerializeField] ComputeShader generationShader;
        [SerializeField] NoiseGenerator noiseGenerator;
        [SerializeField] MeshFilter meshFilter;
        [SerializeField] MeshCollider meshCollider;
        [SerializeField,Range(0, 8), OnValueChanged(nameof(CreateTerrain))] int lodLVL;
        [SerializeField] private int terrainScale;

        Mesh generatedMesh;

        int marchingCubesGenerationKernelID;
        int marchingTetrahedrasGenerationKernelID;
        int updateWeightsKernelID;

        float[] weights;

        struct Triangle
        {
            public Vector3 a;
            public Vector3 b;
            public Vector3 c;

            public static int SizeOf => sizeof(float) * 3 * 3;
        }

        // buffers for transfering data

        //The triangles buffer holds all of our triangle objects that will be generated by marching cubes
        ComputeBuffer trianglesBuffer;

        //Since we can’t know how many triangles will be generated, we have to keep track of them in triangles count buffer
        ComputeBuffer trianglesCountBuffer;

        //Weights buffer contains the noise values generated in the first part of this tutorial
        ComputeBuffer weightsBuffer;

        private void Awake()
        {
            marchingCubesGenerationKernelID = generationShader.FindKernel("MarchingCubesGeneration");
            //marchingTetrahedrasGenerationKernelID = generationShader.FindKernel("MarchingTetrahedrasGeneration");
            updateWeightsKernelID = generationShader.FindKernel("UpdateWeights");

            GridMetrics.Scale = terrainScale;
            noiseGenerator.onValuesChanged += CreateTerrainOnNoiseChanged;
        }

        private void Start()
        {
            CreateTerrain();
        }

        void CreateTerrainOnNoiseChanged() => CreateTerrain(true);

        private void CreateTerrain(bool regenerateWeights = false)
        {
            CreateBuffers();
            if (weights == null || regenerateWeights)
            {
                weights = noiseGenerator.GetNoise(GridMetrics.LastLodLvl);
            }
            //weights = noiseGenerator.GetNoise(lodLVL);
            generatedMesh = new Mesh();
            UpdateMesh();
            ReleaseBuffers();
        }

        void UpdateMesh()
        {
            Mesh mesh = CreateMesh();
            meshFilter.sharedMesh = mesh;
            meshCollider.sharedMesh = mesh;
        }

        public void EditWeights(Vector3 hitPosition, float brushSize, bool add)
        {
            CreateBuffers();

            weightsBuffer.SetData(weights);
            generationShader.SetBuffer(updateWeightsKernelID, "_Weights", weightsBuffer);

            generationShader.SetInt("_ChunkSize", GridMetrics.PointsPerChunk(GridMetrics.LastLodLvl));
            generationShader.SetVector("_HitPosition", hitPosition);
            generationShader.SetFloat("_BrushSize", brushSize);
            generationShader.SetFloat("_TerraformStrength", add ? 1f : -1f);
            generationShader.SetInt("_Scale", GridMetrics.Scale);

            generationShader.Dispatch(updateWeightsKernelID, GridMetrics.ThreadGroups(GridMetrics.LastLodLvl), GridMetrics.ThreadGroups(GridMetrics.LastLodLvl), GridMetrics.ThreadGroups(GridMetrics.LastLodLvl));

            weightsBuffer.GetData(weights);

            UpdateMesh();
            ReleaseBuffers();
        }

        Mesh CreateMesh()
        {
            generationShader.SetBuffer(marchingCubesGenerationKernelID, "_Triangles", trianglesBuffer);
            generationShader.SetBuffer(marchingCubesGenerationKernelID, "_Weights", weightsBuffer);

            generationShader.SetInt("_ChunkSize", GridMetrics.PointsPerChunk(GridMetrics.LastLodLvl));
            generationShader.SetFloat("_IsoLevel", .5f);
            generationShader.SetInt("_Scale", GridMetrics.Scale);
            generationShader.SetInt("_LODSize", GridMetrics.PointsPerChunk(lodLVL));

            float lodScaleFactor = ((float)GridMetrics.PointsPerChunk(GridMetrics.LastLodLvl) + 1) / (float)GridMetrics.PointsPerChunk(lodLVL);

            generationShader.SetFloat("_LodScaleFactor", lodScaleFactor);

            weightsBuffer.SetData(weights);
            trianglesBuffer.SetCounterValue(0);


            generationShader.Dispatch(marchingCubesGenerationKernelID, GridMetrics.ThreadGroups(lodLVL), GridMetrics.ThreadGroups(lodLVL), GridMetrics.ThreadGroups(lodLVL));

            Triangle[] triangles = new Triangle[GetTriangleCount()];
            trianglesBuffer.GetData(triangles);

            return CreateMeshFromTriangles(triangles);
        }

        private void CreateBuffers()
        {
            var bufferCount = GridMetrics.PointsPerChunk(lodLVL) * GridMetrics.PointsPerChunk(lodLVL) * GridMetrics.PointsPerChunk(lodLVL);

            //we have to tell the buffers the maximum amount of elements it can contain,
            //we need to initialize the trianglesBuffer with 5 * the total grid size.
            //5 is derived from the fact that there can at most be 5 triangles per cube configuration.

            //We already defined the size of a single triangle which is the stride of the buffer.
            //We also have to make our buffer of type append. Just as a regular buffer is similar to an array,
            //the append buffer is similar to a list. Instead of having to use an index to add to the list, we can simply call list.Append(myElement)

            //The triangles count buffer will simply contain a single integer.

            //The weightsBuffer, just like the weightsBuffer in the NoiseGenerator, contains a single float value per point in the 3D grid.

            trianglesBuffer = new ComputeBuffer(5 * bufferCount, Triangle.SizeOf, ComputeBufferType.Append);
            trianglesCountBuffer = new ComputeBuffer(1, sizeof(int), ComputeBufferType.Raw);
            weightsBuffer = new ComputeBuffer(GridMetrics.PointsPerChunk(GridMetrics.LastLodLvl) * GridMetrics.PointsPerChunk(GridMetrics.LastLodLvl) * GridMetrics.PointsPerChunk(GridMetrics.LastLodLvl), sizeof(float));
        }

        private void ReleaseBuffers()
        {
            trianglesBuffer.Release();
            trianglesCountBuffer.Release();
            weightsBuffer.Release();
        }



        //In case you are wondering why we can’t just use _trianglesBuffer.count (which is an existing function),
        //the .count gives us the max capacity of the buffer, not the actual length of the appendBuffer.
        int GetTriangleCount()
        {
            int[] triCount = { 0 };
            ComputeBuffer.CopyCount(trianglesBuffer, trianglesCountBuffer, 0);
            trianglesCountBuffer.GetData(triCount);
            return triCount[0];
        }

        Mesh CreateMeshFromTriangles(Triangle[] triangles)
        {
            // Initialize the vertices and triangles list(this is for our mesh data).
            // Every triangle contains 3 vertices so we will need triangles.Length * 3 as size of our vertices and triangles array.

            Vector3[] vertices = new Vector3[triangles.Length * 3];
            int[] tris = new int[triangles.Length * 3];

            //Loop through all triangles generated by marching cubes, and add them to our verts and tris.

            for (int i = 0; i < triangles.Length; i++)
            {
                int startIndex = i * 3;
                vertices[startIndex] = triangles[i].a;
                vertices[startIndex + 1] = triangles[i].b;
                vertices[startIndex + 2] = triangles[i].c;
                tris[startIndex] = startIndex;
                tris[startIndex + 1] = startIndex + 1;
                tris[startIndex + 2] = startIndex + 2;
            }

            generatedMesh.Clear();
            generatedMesh.vertices = vertices;
            generatedMesh.triangles = tris;
            generatedMesh.RecalculateNormals();
            return generatedMesh;
        }

        //private void DrawTerrain()
        //{
        //    drawBuffer.SetCounterValue(0);

        //    //update the shader with frame specific data
        //    generateTerrainComputeShader.SetMatrix("_localToWorld", transform.localToWorldMatrix);

        //    //dispatch the pyramid shader . it will run on the gpu
        //    generateTerrainComputeShader.Dispatch(idDataGenerationKernel, dispatchSize, 1, 1);

        //    //copy the count (stack size) of the draw buffer to the args buffer,at the byte position zero
        //    // this sets vertex  count for our draw procedural indirect call
        //    ComputeBuffer.CopyCount(drawBuffer, argsBuffer, 0);

        //    //this the compute shader outputs triangles, but grpahics shader needs the number of vertices, 
        //    //we need to multiply the vertex count by three . we'll do this on the gpu with a compute shader
        //    // so we dont have to transfer data back to the cpu
        //    triToVertComputeShader.Dispatch(idTriToVertKernel, 1, 1, 1);

        //    //DrawProceduralIndirect queues a draw call up for out generated mesh
        //    // it will recive a shadow casting pass, like normal
        //    Graphics.DrawProceduralIndirect(material, TransformBounds(localBounds), MeshTopology.Triangles, argsBuffer, 0, null, null, UnityEngine.Rendering.ShadowCastingMode.On, true, gameObject.layer);
        //}

        //private Bounds TransformBounds(Bounds localBounds) // transform bounds to world space
        //{
        //    var center = transform.TransformPoint(localBounds.center);

        //    // transform the local extents axes
        //    var extents = localBounds.extents;
        //    var axisX = transform.TransformVector(extents.x, 0, 0);
        //    var axisY = transform.TransformVector(0, extents.y, 0);
        //    var axisZ = transform.TransformVector(0, 0, extents.z);

        //    //sume their absolute val to get the world extents
        //    extents.x = Mathf.Abs(axisX.x) + Mathf.Abs(axisY.x) + Mathf.Abs(axisZ.x);
        //    extents.y = Mathf.Abs(axisX.y) + Mathf.Abs(axisY.y) + Mathf.Abs(axisZ.y);
        //    extents.z = Mathf.Abs(axisX.z) + Mathf.Abs(axisY.z) + Mathf.Abs(axisZ.z);

        //    return new Bounds(center, extents);
        //}
    }
}